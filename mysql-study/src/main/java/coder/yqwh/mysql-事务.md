##事务隔离级别
  >* 1.未提交读   》导致脏读问题
  >* 2.提交读 【不可重复读】 大多数数据库系统默认隔离级别都是提交读，但mysql不是 两次执行同样的查询。可能会得到不一样的结果
  >* 3.可重复读  解决了脏读问题 mysql默认事务隔离级别  【innodb存储引擎通过MVCC解决了幻读的问题】
  >* 4.可串行化 避免幻读问题。性能低【事务a查询某个范围的数据，事务b插入该范围的记录，会产生幻行】

##死锁
>* 【问题】 两个或者多个事务在同一资源上相互占用资源，可能会产生死锁  
>* 【场景】打个比方，事务1持有第三行数据的锁，想去获取第四行数据的锁；与此同时，事务2持有第四行数据的锁，想去获取第三行数据的锁。双方互不释放锁，陷入死循环。
>* 【解决方案】innodb存储引擎实现了死锁检测和死锁超时机制。将持有最少行级排他锁的事务进行回滚

##事务日志
>* 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
   事务日志采用的是追加的方式，写日志的操作是顺序IO比随机IO快很多。
   
##MVCC多版本并发控制
>* MVCC的实现，是通过保存数据在某个时间点的快照来实现的。
>* innodb的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然保存的并不是实际的
   时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版
   本号进行比较。【不可重复读隔离级别下面的innodb】 <br/>
   【select】<br/>
   条件一：innodb只查找行的系统版本号小于或等于事务的系统版本号。这样可以确保事务读取的行，要么在事务开始前已经存在，要么在事务自身插入或修改过的。
   条件二：行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。
   只有服务上述两个条件的记录，才能返回作为查询结果。<br/>
   【insert】<br/>
   InnoDB为新插入的每一行保存当前系统版本号作为行版本号。<br/>
   【delete】<br/>
   InnoDB为删除的每一行保存当前系统版本号作为行删除标识。<br/>
   【update】<br/>
   InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。<br/>
   【注意】<br/>
   MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容!<br/>
   READ UNCOMMITTED总是读取最新的数据行;<br/>
   而SERIALIZABLE则会对所有读取的行都加锁。<br/>